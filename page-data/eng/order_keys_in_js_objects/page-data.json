{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/eng/order_keys_in_js_objects/","result":{"data":{"site":{"siteMetadata":{"title":"cdROma.me","siteUrl":"https://cdroma.me"}},"markdownRemark":{"html":"<p>In JS, objects were 'unordered' until ES5. Starting from ES6, there is a predictable order of iterating through an object's properties.</p>\n<ol>\n<li>\n<p>All non-negative integer keys less than 2^32, in ascending order. (e.g., '1', '79', etc.). Typically, all valid array indexes. (non-negative numbers up to 2^32)</p>\n<blockquote>\n<p><em>Warning</em>: '05' will not be considered an integer key, as the integer parsed from it yields a different string representation.</p>\n</blockquote>\n</li>\n<li>\n<p>All string keys in the order of insertion (in the order they were added to the object).</p>\n<blockquote>\n<p>Here, numeric strings not falling within the first step and floating-point numbers will be covered.</p>\n</blockquote>\n</li>\n<li>\n<p>Properties whose names are symbols are listed in the order in which they were added to the object.</p>\n</li>\n</ol>\n<p>If the enumeration order is relevant, you can always use Map, which guarantees that the insertion order will be preserved.</p>\n<h2>Functions that enumerate properties in the order described above, taking into account their own limitations</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys()</code></a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\"><code>Object.getOwnPropertyNames()</code></a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\"><code>Object.getOwnPropertySymbols()</code></a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys\"><code>Reflect.ownKeys()</code></a></li>\n</ul>\n<blockquote>\n<p>Note that the enumeration order for the <strong>for in</strong> loop is not as strictly defined as for the above functions, but usually, the enumeration of own properties occurs in the order described above.</p>\n</blockquote>\n<blockquote>\n<p>Since the <strong>for in</strong> loop also enumerates properties in the prototype chain, after enumerating own properties, it will move <em>up the prototype chain</em>, enumerating the properties of each prototype object <em>in the same order as described above</em>.</p>\n</blockquote>\n<blockquote>\n<p>If a property has already been enumerated, any property with the same name will <strong>not be</strong> enumerated again.</p>\n</blockquote>\n<blockquote>\n<p>A property will <strong>not be</strong> enumerated, even if an enumerable property with the same name has already been considered.</p>\n</blockquote>","id":"1333036c-3925-5a42-ab0a-e415732b585b","frontmatter":{"title":"Order of Storing/Enumerating Keys in a JS Object","description":"This article explores the order of storing and enumerating keys in JavaScript objects, a concept that gained predictability with ES6. It covers the sorting of integer keys, string keys, and symbol-named properties, and highlights the functions that respect this order, like Object.keys() and Reflect.ownKeys(). Understanding this order is vital for JavaScript developers dealing with object property iteration.","keywords":"JavaScript objects, key enumeration, ES6 features, object property order, integer keys, string keys, symbol properties, Object.keys, Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Reflect.ownKeys, for-in loop, prototype chain enumeration, property sorting in JavaScript, JS object properties, ES6 object iteration, web development, JavaScript programming, coding standards, ES6 standards, JavaScript property order"}}},"pageContext":{"slug":"/eng/order_keys_in_js_objects/"}},"staticQueryHashes":["1777174035","3159585216"],"slicesMap":{}}